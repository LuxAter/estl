<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Estl: estl::vector::Vector&lt; _Tp, _N, _Al &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Estl
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceestl.html">estl</a></li><li class="navelem"><b>vector</b></li><li class="navelem"><a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">estl::vector::Vector&lt; _Tp, _N, _Al &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A standard container representing a mathmatical vector.  
 <a href="classestl_1_1vector_1_1Vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a24e6b35e87f1bd52760e1adeba51538d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24e6b35e87f1bd52760e1adeba51538d"></a>
typedef _Al&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a24e6b35e87f1bd52760e1adeba51538d">allocator_type</a></td></tr>
<tr class="memdesc:a24e6b35e87f1bd52760e1adeba51538d"><td class="mdescLeft">&#160;</td><td class="mdescRight">_Al <br/></td></tr>
<tr class="separator:a24e6b35e87f1bd52760e1adeba51538d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b44de2b4b580f6bccefa391398550b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60b44de2b4b580f6bccefa391398550b"></a>
typedef _Al::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a60b44de2b4b580f6bccefa391398550b">value_type</a></td></tr>
<tr class="memdesc:a60b44de2b4b580f6bccefa391398550b"><td class="mdescLeft">&#160;</td><td class="mdescRight">_Tp <br/></td></tr>
<tr class="separator:a60b44de2b4b580f6bccefa391398550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975aa911d330359b5d7e0d2e99fbee11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a975aa911d330359b5d7e0d2e99fbee11"></a>
typedef _Al::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a975aa911d330359b5d7e0d2e99fbee11">reference</a></td></tr>
<tr class="memdesc:a975aa911d330359b5d7e0d2e99fbee11"><td class="mdescLeft">&#160;</td><td class="mdescRight">value_type&amp; <br/></td></tr>
<tr class="separator:a975aa911d330359b5d7e0d2e99fbee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c0a66ac351178d43d81e05062a56c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1c0a66ac351178d43d81e05062a56c7"></a>
typedef _Al::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ac1c0a66ac351178d43d81e05062a56c7">const_reference</a></td></tr>
<tr class="memdesc:ac1c0a66ac351178d43d81e05062a56c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">const value_type&amp; <br/></td></tr>
<tr class="separator:ac1c0a66ac351178d43d81e05062a56c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc179389ca45a0ea948e45cc20801e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cc179389ca45a0ea948e45cc20801e6"></a>
typedef _Al::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a3cc179389ca45a0ea948e45cc20801e6">difference_type</a></td></tr>
<tr class="memdesc:a3cc179389ca45a0ea948e45cc20801e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::ptrdiff_t <br/></td></tr>
<tr class="separator:a3cc179389ca45a0ea948e45cc20801e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae155658c9b8cef8e57ab11fbb9e9bcff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae155658c9b8cef8e57ab11fbb9e9bcff"></a>
typedef _Al::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a></td></tr>
<tr class="memdesc:ae155658c9b8cef8e57ab11fbb9e9bcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::size_t <br/></td></tr>
<tr class="separator:ae155658c9b8cef8e57ab11fbb9e9bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce99e05dd558f5840bb88e3509edca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ce99e05dd558f5840bb88e3509edca2"></a>
typedef _Al::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a4ce99e05dd558f5840bb88e3509edca2">pointer</a></td></tr>
<tr class="memdesc:a4ce99e05dd558f5840bb88e3509edca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">value_type* <br/></td></tr>
<tr class="separator:a4ce99e05dd558f5840bb88e3509edca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246922d9af90c7711c8e9e9ca65b34b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a246922d9af90c7711c8e9e9ca65b34b9"></a>
typedef _Al::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a246922d9af90c7711c8e9e9ca65b34b9">const_pointer</a></td></tr>
<tr class="memdesc:a246922d9af90c7711c8e9e9ca65b34b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">const value_type* <br/></td></tr>
<tr class="separator:a246922d9af90c7711c8e9e9ca65b34b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a0f0535f0e0a11fe1943a44c9ff607"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13a0f0535f0e0a11fe1943a44c9ff607"></a>
typedef _Al::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a13a0f0535f0e0a11fe1943a44c9ff607">iterator</a></td></tr>
<tr class="memdesc:a13a0f0535f0e0a11fe1943a44c9ff607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access iterator. <br/></td></tr>
<tr class="separator:a13a0f0535f0e0a11fe1943a44c9ff607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813f3151350d6fe485639252b8c892b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a813f3151350d6fe485639252b8c892b6"></a>
typedef _Al::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a></td></tr>
<tr class="memdesc:a813f3151350d6fe485639252b8c892b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant random access iterator. <br/></td></tr>
<tr class="separator:a813f3151350d6fe485639252b8c892b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e2a22c217006092bd7449aee770728"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12e2a22c217006092bd7449aee770728"></a>
typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="classestl_1_1vector_1_1Vector.html#a13a0f0535f0e0a11fe1943a44c9ff607">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a12e2a22c217006092bd7449aee770728">reverse_iterator</a></td></tr>
<tr class="memdesc:a12e2a22c217006092bd7449aee770728"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::reverse_iterator&lt;iterator&gt; <br/></td></tr>
<tr class="separator:a12e2a22c217006092bd7449aee770728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca27cb927d826239612f023d3b6652b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca27cb927d826239612f023d3b6652b6"></a>
typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a></td></tr>
<tr class="memdesc:aca27cb927d826239612f023d3b6652b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::reverse_iterator&lt;const_iterator&gt; <br/></td></tr>
<tr class="separator:aca27cb927d826239612f023d3b6652b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1409797c8babaabd8db57c241e9b6b45"><td class="memTemplParams" colspan="2">template&lt;typename _T &gt; </td></tr>
<tr class="memitem:a1409797c8babaabd8db57c241e9b6b45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a1409797c8babaabd8db57c241e9b6b45">operator+=</a> (const _T &amp;rhs)</td></tr>
<tr class="memdesc:a1409797c8babaabd8db57c241e9b6b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compound assignment of two vectors or a vector and a scalar.  <a href="#a1409797c8babaabd8db57c241e9b6b45">More...</a><br/></td></tr>
<tr class="separator:a1409797c8babaabd8db57c241e9b6b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71abe1d1aa0232466339366fba775ce6"><td class="memTemplParams" colspan="2">template&lt;typename _T &gt; </td></tr>
<tr class="memitem:a71abe1d1aa0232466339366fba775ce6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a71abe1d1aa0232466339366fba775ce6">operator-=</a> (const _T &amp;rhs)</td></tr>
<tr class="memdesc:a71abe1d1aa0232466339366fba775ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compound assignment of two vectors or a vector and a scalar.  <a href="#a71abe1d1aa0232466339366fba775ce6">More...</a><br/></td></tr>
<tr class="separator:a71abe1d1aa0232466339366fba775ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e7a9be81dd41a4b13ecf72f5c3e72d"><td class="memTemplParams" colspan="2">template&lt;typename _T &gt; </td></tr>
<tr class="memitem:ad4e7a9be81dd41a4b13ecf72f5c3e72d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ad4e7a9be81dd41a4b13ecf72f5c3e72d">operator*=</a> (const _T &amp;rhs)</td></tr>
<tr class="memdesc:ad4e7a9be81dd41a4b13ecf72f5c3e72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compound assignment of two vectors or a vector and a scalar.  <a href="#ad4e7a9be81dd41a4b13ecf72f5c3e72d">More...</a><br/></td></tr>
<tr class="separator:ad4e7a9be81dd41a4b13ecf72f5c3e72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76b3ef91b33255e20ff01b38e88fba5"><td class="memTemplParams" colspan="2">template&lt;typename _T &gt; </td></tr>
<tr class="memitem:aa76b3ef91b33255e20ff01b38e88fba5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#aa76b3ef91b33255e20ff01b38e88fba5">operator/=</a> (const _T &amp;rhs)</td></tr>
<tr class="memdesc:aa76b3ef91b33255e20ff01b38e88fba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compound assignment of two vectors or a vector and a scalar.  <a href="#aa76b3ef91b33255e20ff01b38e88fba5">More...</a><br/></td></tr>
<tr class="separator:aa76b3ef91b33255e20ff01b38e88fba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor</div></td></tr>
<tr class="memitem:a0512c84eb9da2ef96933c52e53f83b0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a0512c84eb9da2ef96933c52e53f83b0e">Vector</a> ()</td></tr>
<tr class="memdesc:a0512c84eb9da2ef96933c52e53f83b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default vector constructor.  <a href="#a0512c84eb9da2ef96933c52e53f83b0e">More...</a><br/></td></tr>
<tr class="separator:a0512c84eb9da2ef96933c52e53f83b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bd7e927c5bff1c8ddb4fdfc245e24e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ac7bd7e927c5bff1c8ddb4fdfc245e24e">Vector</a> (_Tp val)</td></tr>
<tr class="memdesc:ac7bd7e927c5bff1c8ddb4fdfc245e24e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> constructor.  <a href="#ac7bd7e927c5bff1c8ddb4fdfc245e24e">More...</a><br/></td></tr>
<tr class="separator:ac7bd7e927c5bff1c8ddb4fdfc245e24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc123e158aedc61ea2be0110a379bda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#abcc123e158aedc61ea2be0110a379bda">Vector</a> (const std::initializer_list&lt; _Tp &gt; &amp;vec)</td></tr>
<tr class="memdesc:abcc123e158aedc61ea2be0110a379bda"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> constructor.  <a href="#abcc123e158aedc61ea2be0110a379bda">More...</a><br/></td></tr>
<tr class="separator:abcc123e158aedc61ea2be0110a379bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c2b54163113acb7a0e6f1a83eba65f"><td class="memTemplParams" colspan="2">template&lt;class _InputIt &gt; </td></tr>
<tr class="memitem:af0c2b54163113acb7a0e6f1a83eba65f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#af0c2b54163113acb7a0e6f1a83eba65f">Vector</a> (_InputIt first, _InputIt last)</td></tr>
<tr class="memdesc:af0c2b54163113acb7a0e6f1a83eba65f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> constructor.  <a href="#af0c2b54163113acb7a0e6f1a83eba65f">More...</a><br/></td></tr>
<tr class="separator:af0c2b54163113acb7a0e6f1a83eba65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44885ca899838a4fe81a24e0127e9d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae44885ca899838a4fe81a24e0127e9d9">Vector</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> &amp;vec)</td></tr>
<tr class="memdesc:ae44885ca899838a4fe81a24e0127e9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ae44885ca899838a4fe81a24e0127e9d9">More...</a><br/></td></tr>
<tr class="separator:ae44885ca899838a4fe81a24e0127e9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fa9b4cf1bb1c4df2cb2ee058a16896"><td class="memTemplParams" colspan="2">template&lt;std::size_t _Nc&gt; </td></tr>
<tr class="memitem:af1fa9b4cf1bb1c4df2cb2ee058a16896"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#af1fa9b4cf1bb1c4df2cb2ee058a16896">Vector</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a>&lt; _Tp, _Nc &gt; vec, _Tp val)</td></tr>
<tr class="memdesc:af1fa9b4cf1bb1c4df2cb2ee058a16896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#af1fa9b4cf1bb1c4df2cb2ee058a16896">More...</a><br/></td></tr>
<tr class="separator:af1fa9b4cf1bb1c4df2cb2ee058a16896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a118fec838f2ae13ea08e07eb6adeb5e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a118fec838f2ae13ea08e07eb6adeb5e2">~Vector</a> ()</td></tr>
<tr class="memdesc:a118fec838f2ae13ea08e07eb6adeb5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a118fec838f2ae13ea08e07eb6adeb5e2">More...</a><br/></td></tr>
<tr class="separator:a118fec838f2ae13ea08e07eb6adeb5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operator=</div></td></tr>
<tr class="memitem:a1dbd7b540a8842e2eff08fb2357d9775"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dbd7b540a8842e2eff08fb2357d9775"></a>
<a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> &amp;vec)</td></tr>
<tr class="separator:a1dbd7b540a8842e2eff08fb2357d9775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a69c6885af1c0add1d2ae352a0fb7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71a69c6885af1c0add1d2ae352a0fb7b"></a>
<a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const std::initializer_list&lt; _Tp &gt; &amp;vec)</td></tr>
<tr class="separator:a71a69c6885af1c0add1d2ae352a0fb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element Access</div></td></tr>
<tr class="memitem:a2e2d618ae707d488b451489937bd5282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a975aa911d330359b5d7e0d2e99fbee11">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a2e2d618ae707d488b451489937bd5282">at</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> i)</td></tr>
<tr class="memdesc:a2e2d618ae707d488b451489937bd5282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element with bounds checking.  <a href="#a2e2d618ae707d488b451489937bd5282">More...</a><br/></td></tr>
<tr class="separator:a2e2d618ae707d488b451489937bd5282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228a5d1a6a4eab6fa95aa17efd66025f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ac1c0a66ac351178d43d81e05062a56c7">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a228a5d1a6a4eab6fa95aa17efd66025f">at</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> i) const </td></tr>
<tr class="memdesc:a228a5d1a6a4eab6fa95aa17efd66025f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element with bounds checking.  <a href="#a228a5d1a6a4eab6fa95aa17efd66025f">More...</a><br/></td></tr>
<tr class="separator:a228a5d1a6a4eab6fa95aa17efd66025f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214d4c14b9e22e8b5769a261e1051ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a975aa911d330359b5d7e0d2e99fbee11">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a214d4c14b9e22e8b5769a261e1051ea7">operator[]</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> i) noexcept</td></tr>
<tr class="memdesc:a214d4c14b9e22e8b5769a261e1051ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element.  <a href="#a214d4c14b9e22e8b5769a261e1051ea7">More...</a><br/></td></tr>
<tr class="separator:a214d4c14b9e22e8b5769a261e1051ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0f94919877665b7e85c580c98926f4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ac1c0a66ac351178d43d81e05062a56c7">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a3b0f94919877665b7e85c580c98926f4">operator[]</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> i) const noexcept</td></tr>
<tr class="memdesc:a3b0f94919877665b7e85c580c98926f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element.  <a href="#a3b0f94919877665b7e85c580c98926f4">More...</a><br/></td></tr>
<tr class="separator:a3b0f94919877665b7e85c580c98926f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb050b92bf0b3bd933739bf0c43c59ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a975aa911d330359b5d7e0d2e99fbee11">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#acb050b92bf0b3bd933739bf0c43c59ca">front</a> ()</td></tr>
<tr class="memdesc:acb050b92bf0b3bd933739bf0c43c59ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="#acb050b92bf0b3bd933739bf0c43c59ca">More...</a><br/></td></tr>
<tr class="separator:acb050b92bf0b3bd933739bf0c43c59ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bb0d2b7b352aef31fbcf3e3273a837"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ac1c0a66ac351178d43d81e05062a56c7">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#af9bb0d2b7b352aef31fbcf3e3273a837">font</a> () const </td></tr>
<tr class="memdesc:af9bb0d2b7b352aef31fbcf3e3273a837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the first element.  <a href="#af9bb0d2b7b352aef31fbcf3e3273a837">More...</a><br/></td></tr>
<tr class="separator:af9bb0d2b7b352aef31fbcf3e3273a837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4aab6274fb1748ab1029d8511b6a244"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a975aa911d330359b5d7e0d2e99fbee11">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#af4aab6274fb1748ab1029d8511b6a244">back</a> ()</td></tr>
<tr class="memdesc:af4aab6274fb1748ab1029d8511b6a244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="#af4aab6274fb1748ab1029d8511b6a244">More...</a><br/></td></tr>
<tr class="separator:af4aab6274fb1748ab1029d8511b6a244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de38f429792b4a2ad24e528b6625c1f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ac1c0a66ac351178d43d81e05062a56c7">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a3de38f429792b4a2ad24e528b6625c1f">back</a> () const </td></tr>
<tr class="memdesc:a3de38f429792b4a2ad24e528b6625c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the last element.  <a href="#a3de38f429792b4a2ad24e528b6625c1f">More...</a><br/></td></tr>
<tr class="separator:a3de38f429792b4a2ad24e528b6625c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca694ce7312008b4a3f55ac93a8bc5f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a4ce99e05dd558f5840bb88e3509edca2">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca694ce7312008b4a3f55ac93a8bc5f9">data</a> ()</td></tr>
<tr class="memdesc:aca694ce7312008b4a3f55ac93a8bc5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the underlying array.  <a href="#aca694ce7312008b4a3f55ac93a8bc5f9">More...</a><br/></td></tr>
<tr class="separator:aca694ce7312008b4a3f55ac93a8bc5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208c8417fb33e0d798ef8ac44b1961b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a246922d9af90c7711c8e9e9ca65b34b9">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a208c8417fb33e0d798ef8ac44b1961b1">data</a> () const </td></tr>
<tr class="memdesc:a208c8417fb33e0d798ef8ac44b1961b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the underlying array.  <a href="#a208c8417fb33e0d798ef8ac44b1961b1">More...</a><br/></td></tr>
<tr class="separator:a208c8417fb33e0d798ef8ac44b1961b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299540243ac3cd73d7b9339f546acc52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1matrix_1_1Matrix.html">estl::matrix::Matrix</a>&lt; _Tp, _N, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a299540243ac3cd73d7b9339f546acc52">as_matrix</a> () const </td></tr>
<tr class="memdesc:a299540243ac3cd73d7b9339f546acc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts vector into matrix.  <a href="#a299540243ac3cd73d7b9339f546acc52">More...</a><br/></td></tr>
<tr class="separator:a299540243ac3cd73d7b9339f546acc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a32a86eea020fc10d5c3b2df4474c34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a0a32a86eea020fc10d5c3b2df4474c34">as_vector</a> () const </td></tr>
<tr class="memdesc:a0a32a86eea020fc10d5c3b2df4474c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access specified element with bounds checking.  <a href="#a0a32a86eea020fc10d5c3b2df4474c34">More...</a><br/></td></tr>
<tr class="separator:a0a32a86eea020fc10d5c3b2df4474c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a0c41d88664c7bd5255c15d6f133c2fd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a13a0f0535f0e0a11fe1943a44c9ff607">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a0c41d88664c7bd5255c15d6f133c2fd5">begin</a> ()</td></tr>
<tr class="memdesc:a0c41d88664c7bd5255c15d6f133c2fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retuns an iterator to the beginning.  <a href="#a0c41d88664c7bd5255c15d6f133c2fd5">More...</a><br/></td></tr>
<tr class="separator:a0c41d88664c7bd5255c15d6f133c2fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c12da6245d1b475cce328f8c5bd72e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a3c12da6245d1b475cce328f8c5bd72e2">begin</a> () const </td></tr>
<tr class="memdesc:a3c12da6245d1b475cce328f8c5bd72e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retuns an iterator to the beginning.  <a href="#a3c12da6245d1b475cce328f8c5bd72e2">More...</a><br/></td></tr>
<tr class="separator:a3c12da6245d1b475cce328f8c5bd72e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8596db46a42eb027956e2829110942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a2e8596db46a42eb027956e2829110942">cbegin</a> () const </td></tr>
<tr class="memdesc:a2e8596db46a42eb027956e2829110942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retuns an iterator to the beginning.  <a href="#a2e8596db46a42eb027956e2829110942">More...</a><br/></td></tr>
<tr class="separator:a2e8596db46a42eb027956e2829110942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03b417b120b029df7e2736cfe61d1ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a13a0f0535f0e0a11fe1943a44c9ff607">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ab03b417b120b029df7e2736cfe61d1ec">end</a> ()</td></tr>
<tr class="memdesc:ab03b417b120b029df7e2736cfe61d1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="#ab03b417b120b029df7e2736cfe61d1ec">More...</a><br/></td></tr>
<tr class="separator:ab03b417b120b029df7e2736cfe61d1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7566150895d27105c0bc6ea07f915e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ad7566150895d27105c0bc6ea07f915e7">end</a> () const </td></tr>
<tr class="memdesc:ad7566150895d27105c0bc6ea07f915e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="#ad7566150895d27105c0bc6ea07f915e7">More...</a><br/></td></tr>
<tr class="separator:ad7566150895d27105c0bc6ea07f915e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59c05f627800e53b492257dc82856bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ab59c05f627800e53b492257dc82856bb">cend</a> () const </td></tr>
<tr class="memdesc:ab59c05f627800e53b492257dc82856bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end.  <a href="#ab59c05f627800e53b492257dc82856bb">More...</a><br/></td></tr>
<tr class="separator:ab59c05f627800e53b492257dc82856bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6257898f724d9e616185dcea9a0e5ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a12e2a22c217006092bd7449aee770728">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#af6257898f724d9e616185dcea9a0e5ee">rbegin</a> ()</td></tr>
<tr class="memdesc:af6257898f724d9e616185dcea9a0e5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="#af6257898f724d9e616185dcea9a0e5ee">More...</a><br/></td></tr>
<tr class="separator:af6257898f724d9e616185dcea9a0e5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6536f15f1948d1c6c2a60ad2ed1f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a2d6536f15f1948d1c6c2a60ad2ed1f09">rbegin</a> () const </td></tr>
<tr class="memdesc:a2d6536f15f1948d1c6c2a60ad2ed1f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="#a2d6536f15f1948d1c6c2a60ad2ed1f09">More...</a><br/></td></tr>
<tr class="separator:a2d6536f15f1948d1c6c2a60ad2ed1f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ade181925e9488c82616252161e098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a84ade181925e9488c82616252161e098">crbegin</a> () const </td></tr>
<tr class="memdesc:a84ade181925e9488c82616252161e098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the beginning.  <a href="#a84ade181925e9488c82616252161e098">More...</a><br/></td></tr>
<tr class="separator:a84ade181925e9488c82616252161e098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eec92c7c08a90edd5a038f4fc01e0f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a12e2a22c217006092bd7449aee770728">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a0eec92c7c08a90edd5a038f4fc01e0f4">rend</a> ()</td></tr>
<tr class="memdesc:a0eec92c7c08a90edd5a038f4fc01e0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="#a0eec92c7c08a90edd5a038f4fc01e0f4">More...</a><br/></td></tr>
<tr class="separator:a0eec92c7c08a90edd5a038f4fc01e0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b51665b8c53c0c0a6a00d30ba488c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a7b51665b8c53c0c0a6a00d30ba488c7c">rend</a> () const </td></tr>
<tr class="memdesc:a7b51665b8c53c0c0a6a00d30ba488c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="#a7b51665b8c53c0c0a6a00d30ba488c7c">More...</a><br/></td></tr>
<tr class="separator:a7b51665b8c53c0c0a6a00d30ba488c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a10764afb7d8bd6d6baebd1c18e6430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a2a10764afb7d8bd6d6baebd1c18e6430">crend</a> () const </td></tr>
<tr class="memdesc:a2a10764afb7d8bd6d6baebd1c18e6430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the end.  <a href="#a2a10764afb7d8bd6d6baebd1c18e6430">More...</a><br/></td></tr>
<tr class="separator:a2a10764afb7d8bd6d6baebd1c18e6430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028a8acfc4a9fab5410b2fda87cced67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a13a0f0535f0e0a11fe1943a44c9ff607">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a028a8acfc4a9fab5410b2fda87cced67">element</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> i)</td></tr>
<tr class="memdesc:a028a8acfc4a9fab5410b2fda87cced67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to specified element.  <a href="#a028a8acfc4a9fab5410b2fda87cced67">More...</a><br/></td></tr>
<tr class="separator:a028a8acfc4a9fab5410b2fda87cced67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38552d1615079dd68acf60d3c99620cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a38552d1615079dd68acf60d3c99620cc">element</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> i) const </td></tr>
<tr class="memdesc:a38552d1615079dd68acf60d3c99620cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to specified element.  <a href="#a38552d1615079dd68acf60d3c99620cc">More...</a><br/></td></tr>
<tr class="separator:a38552d1615079dd68acf60d3c99620cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2aa14ed32faba6db68a82734bc65a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a5c2aa14ed32faba6db68a82734bc65a8">celement</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> i) const </td></tr>
<tr class="memdesc:a5c2aa14ed32faba6db68a82734bc65a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to specified element.  <a href="#a5c2aa14ed32faba6db68a82734bc65a8">More...</a><br/></td></tr>
<tr class="separator:a5c2aa14ed32faba6db68a82734bc65a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3d7ee344a0fd59c63db0d88acbdb50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#a12e2a22c217006092bd7449aee770728">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a6c3d7ee344a0fd59c63db0d88acbdb50">relement</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> i)</td></tr>
<tr class="memdesc:a6c3d7ee344a0fd59c63db0d88acbdb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reverse iterator to specified element.  <a href="#a6c3d7ee344a0fd59c63db0d88acbdb50">More...</a><br/></td></tr>
<tr class="separator:a6c3d7ee344a0fd59c63db0d88acbdb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7831218648aa7e8690dbbee785710f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#adb7831218648aa7e8690dbbee785710f">relement</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> i) const </td></tr>
<tr class="memdesc:adb7831218648aa7e8690dbbee785710f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reverse iterator to specified element.  <a href="#adb7831218648aa7e8690dbbee785710f">More...</a><br/></td></tr>
<tr class="separator:adb7831218648aa7e8690dbbee785710f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfd8f6608304be435f821b66d58edc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a2bfd8f6608304be435f821b66d58edc9">crelement</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> i) const </td></tr>
<tr class="memdesc:a2bfd8f6608304be435f821b66d58edc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reverse iterator to specified element.  <a href="#a2bfd8f6608304be435f821b66d58edc9">More...</a><br/></td></tr>
<tr class="separator:a2bfd8f6608304be435f821b66d58edc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr class="memitem:a306fe2dc7af1506e9f0e96af502c86ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a306fe2dc7af1506e9f0e96af502c86ee">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a306fe2dc7af1506e9f0e96af502c86ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="#a306fe2dc7af1506e9f0e96af502c86ee">More...</a><br/></td></tr>
<tr class="separator:a306fe2dc7af1506e9f0e96af502c86ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165c86c512ca83b36300fdf496bdf58a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a165c86c512ca83b36300fdf496bdf58a">size</a> () const noexcept</td></tr>
<tr class="memdesc:a165c86c512ca83b36300fdf496bdf58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements.  <a href="#a165c86c512ca83b36300fdf496bdf58a">More...</a><br/></td></tr>
<tr class="separator:a165c86c512ca83b36300fdf496bdf58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d35025478be6d9256ae5534a69091ca"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a6d35025478be6d9256ae5534a69091ca">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a6d35025478be6d9256ae5534a69091ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible number of elements.  <a href="#a6d35025478be6d9256ae5534a69091ca">More...</a><br/></td></tr>
<tr class="separator:a6d35025478be6d9256ae5534a69091ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations</div></td></tr>
<tr class="memitem:aa6155f45c87f00a051d100f7f7997b9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#aa6155f45c87f00a051d100f7f7997b9f">fill</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html#a60b44de2b4b580f6bccefa391398550b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:aa6155f45c87f00a051d100f7f7997b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the container with specified value.  <a href="#aa6155f45c87f00a051d100f7f7997b9f">More...</a><br/></td></tr>
<tr class="separator:aa6155f45c87f00a051d100f7f7997b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cf9d4e660804dfe413c72c670e6c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a08cf9d4e660804dfe413c72c670e6c52">swap</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> &amp;other)</td></tr>
<tr class="memdesc:a08cf9d4e660804dfe413c72c670e6c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents.  <a href="#a08cf9d4e660804dfe413c72c670e6c52">More...</a><br/></td></tr>
<tr class="separator:a08cf9d4e660804dfe413c72c670e6c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04854ace12edc8445401a22ad7393542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a04854ace12edc8445401a22ad7393542">operator()</a> (_Tp(*func)(_Tp))</td></tr>
<tr class="memdesc:a04854ace12edc8445401a22ad7393542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms supplied function on elements.  <a href="#a04854ace12edc8445401a22ad7393542">More...</a><br/></td></tr>
<tr class="separator:a04854ace12edc8445401a22ad7393542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:adbd7f77fc3864f178eda7547a74324e5"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N&gt; </td></tr>
<tr class="memitem:adbd7f77fc3864f178eda7547a74324e5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#adbd7f77fc3864f178eda7547a74324e5">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; vec)</td></tr>
<tr class="memdesc:adbd7f77fc3864f178eda7547a74324e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream output operator for <a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">estl::vector::Vector</a>.  <a href="#adbd7f77fc3864f178eda7547a74324e5">More...</a><br/></td></tr>
<tr class="separator:adbd7f77fc3864f178eda7547a74324e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596c0b3989b44a687c27261090da5083"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </td></tr>
<tr class="memitem:a596c0b3989b44a687c27261090da5083"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a596c0b3989b44a687c27261090da5083">operator==</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a596c0b3989b44a687c27261090da5083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares the values in the vector.  <a href="#a596c0b3989b44a687c27261090da5083">More...</a><br/></td></tr>
<tr class="separator:a596c0b3989b44a687c27261090da5083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd6f83e9fbfdad73d4a72e64f008c69"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </td></tr>
<tr class="memitem:a5bd6f83e9fbfdad73d4a72e64f008c69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a5bd6f83e9fbfdad73d4a72e64f008c69">operator!=</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5bd6f83e9fbfdad73d4a72e64f008c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares the values in the vector.  <a href="#a5bd6f83e9fbfdad73d4a72e64f008c69">More...</a><br/></td></tr>
<tr class="separator:a5bd6f83e9fbfdad73d4a72e64f008c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143d10e4d209f7bdea4f530a3f323b4d"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </td></tr>
<tr class="memitem:a143d10e4d209f7bdea4f530a3f323b4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a143d10e4d209f7bdea4f530a3f323b4d">operator&lt;</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a143d10e4d209f7bdea4f530a3f323b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares the values in the vector.  <a href="#a143d10e4d209f7bdea4f530a3f323b4d">More...</a><br/></td></tr>
<tr class="separator:a143d10e4d209f7bdea4f530a3f323b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fb165566554b31708e293da1789f63"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </td></tr>
<tr class="memitem:af1fb165566554b31708e293da1789f63"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#af1fb165566554b31708e293da1789f63">operator&gt;</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af1fb165566554b31708e293da1789f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares the values in the vector.  <a href="#af1fb165566554b31708e293da1789f63">More...</a><br/></td></tr>
<tr class="separator:af1fb165566554b31708e293da1789f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1193ce73fde6fb772519c24c7a078e3"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </td></tr>
<tr class="memitem:ac1193ce73fde6fb772519c24c7a078e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ac1193ce73fde6fb772519c24c7a078e3">operator&lt;=</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac1193ce73fde6fb772519c24c7a078e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares the values in the vector.  <a href="#ac1193ce73fde6fb772519c24c7a078e3">More...</a><br/></td></tr>
<tr class="separator:ac1193ce73fde6fb772519c24c7a078e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18c1015e0785a16fa36b0571c3e4b49"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </td></tr>
<tr class="memitem:ac18c1015e0785a16fa36b0571c3e4b49"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ac18c1015e0785a16fa36b0571c3e4b49">operator&gt;=</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac18c1015e0785a16fa36b0571c3e4b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares the values in the vector.  <a href="#ac18c1015e0785a16fa36b0571c3e4b49">More...</a><br/></td></tr>
<tr class="separator:ac18c1015e0785a16fa36b0571c3e4b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ceed4e2a12e85dd0e7a18ef83c9fea"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N, typename _T &gt; </td></tr>
<tr class="memitem:a35ceed4e2a12e85dd0e7a18ef83c9fea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a35ceed4e2a12e85dd0e7a18ef83c9fea">operator+</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;lhs, const _T &amp;rhs)</td></tr>
<tr class="memdesc:a35ceed4e2a12e85dd0e7a18ef83c9fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms vector arithmetics on a vector and a scalar.  <a href="#a35ceed4e2a12e85dd0e7a18ef83c9fea">More...</a><br/></td></tr>
<tr class="separator:a35ceed4e2a12e85dd0e7a18ef83c9fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9efb0a2bd282f363ce5d9bd1f2331d6"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </td></tr>
<tr class="memitem:ad9efb0a2bd282f363ce5d9bd1f2331d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ad9efb0a2bd282f363ce5d9bd1f2331d6">operator+</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad9efb0a2bd282f363ce5d9bd1f2331d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms vector arithmetics on a vector and another vector.  <a href="#ad9efb0a2bd282f363ce5d9bd1f2331d6">More...</a><br/></td></tr>
<tr class="separator:ad9efb0a2bd282f363ce5d9bd1f2331d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c418f3ca56ea60ac64fd75a1db6795f"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N, typename _T &gt; </td></tr>
<tr class="memitem:a0c418f3ca56ea60ac64fd75a1db6795f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a0c418f3ca56ea60ac64fd75a1db6795f">operator-</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;lhs, const _T &amp;rhs)</td></tr>
<tr class="memdesc:a0c418f3ca56ea60ac64fd75a1db6795f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms vector arithmetics on a vector and a scalar.  <a href="#a0c418f3ca56ea60ac64fd75a1db6795f">More...</a><br/></td></tr>
<tr class="separator:a0c418f3ca56ea60ac64fd75a1db6795f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76eebb11f92d90ddaefec9e16cd40580"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </td></tr>
<tr class="memitem:a76eebb11f92d90ddaefec9e16cd40580"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a76eebb11f92d90ddaefec9e16cd40580">operator-</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a76eebb11f92d90ddaefec9e16cd40580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms vector arithmetics on a vector and another vector.  <a href="#a76eebb11f92d90ddaefec9e16cd40580">More...</a><br/></td></tr>
<tr class="separator:a76eebb11f92d90ddaefec9e16cd40580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13be3c4c651a77fe9dcc279f0c258429"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N, typename _T &gt; </td></tr>
<tr class="memitem:a13be3c4c651a77fe9dcc279f0c258429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a13be3c4c651a77fe9dcc279f0c258429">operator*</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;lhs, const _T &amp;rhs)</td></tr>
<tr class="memdesc:a13be3c4c651a77fe9dcc279f0c258429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms vector arithmetics on a vector and a scalar.  <a href="#a13be3c4c651a77fe9dcc279f0c258429">More...</a><br/></td></tr>
<tr class="separator:a13be3c4c651a77fe9dcc279f0c258429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c530c47c3df0f96df358f08a8798dc"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N, typename _T &gt; </td></tr>
<tr class="memitem:af8c530c47c3df0f96df358f08a8798dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#af8c530c47c3df0f96df358f08a8798dc">operator*</a> (const _T &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af8c530c47c3df0f96df358f08a8798dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms vector arithmetics on a scalar and a vector.  <a href="#af8c530c47c3df0f96df358f08a8798dc">More...</a><br/></td></tr>
<tr class="separator:af8c530c47c3df0f96df358f08a8798dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b5833b438c7541ba83094dd6a159ea"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </td></tr>
<tr class="memitem:a86b5833b438c7541ba83094dd6a159ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a86b5833b438c7541ba83094dd6a159ea">operator*</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a86b5833b438c7541ba83094dd6a159ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms vector arithmetics on a vector and another vector.  <a href="#a86b5833b438c7541ba83094dd6a159ea">More...</a><br/></td></tr>
<tr class="separator:a86b5833b438c7541ba83094dd6a159ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4908dfcae8559694dbb147c318ad1d7"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N, std::size_t _Nr&gt; </td></tr>
<tr class="memitem:ae4908dfcae8559694dbb147c318ad1d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _Nr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae4908dfcae8559694dbb147c318ad1d7">operator*</a> (const <a class="el" href="classestl_1_1matrix_1_1Matrix.html">estl::matrix::Matrix</a>&lt; _Tp, _Nr, _N &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae4908dfcae8559694dbb147c318ad1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiples matrix by vector, results in a vector.  <a href="#ae4908dfcae8559694dbb147c318ad1d7">More...</a><br/></td></tr>
<tr class="separator:ae4908dfcae8559694dbb147c318ad1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23de99b2d76cfdc7a9e3ed8445f264cc"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N, typename _T &gt; </td></tr>
<tr class="memitem:a23de99b2d76cfdc7a9e3ed8445f264cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a23de99b2d76cfdc7a9e3ed8445f264cc">operator/</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;lhs, const _T &amp;rhs)</td></tr>
<tr class="memdesc:a23de99b2d76cfdc7a9e3ed8445f264cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms vector arithmetics on a vector and a scalar.  <a href="#a23de99b2d76cfdc7a9e3ed8445f264cc">More...</a><br/></td></tr>
<tr class="separator:a23de99b2d76cfdc7a9e3ed8445f264cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69901c1b931f3e1286401886447f92e0"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </td></tr>
<tr class="memitem:a69901c1b931f3e1286401886447f92e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a69901c1b931f3e1286401886447f92e0">operator/</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a69901c1b931f3e1286401886447f92e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms vector arithmetics on a vector and another vector.  <a href="#a69901c1b931f3e1286401886447f92e0">More...</a><br/></td></tr>
<tr class="separator:a69901c1b931f3e1286401886447f92e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions</div></td></tr>
<tr class="memitem:a8e6ab68502bc9f0a775ebe511b23b480"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N&gt; </td></tr>
<tr class="memitem:a8e6ab68502bc9f0a775ebe511b23b480"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a8e6ab68502bc9f0a775ebe511b23b480">sum</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;lhs)</td></tr>
<tr class="memdesc:a8e6ab68502bc9f0a775ebe511b23b480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the sum of elements of the vector.  <a href="#a8e6ab68502bc9f0a775ebe511b23b480">More...</a><br/></td></tr>
<tr class="separator:a8e6ab68502bc9f0a775ebe511b23b480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3b7f47a2c35c580253ae44da4bbe6f"><td class="memTemplParams" colspan="2">template&lt;typename _TpA , typename _TpB , std::size_t _N&gt; </td></tr>
<tr class="memitem:ace3b7f47a2c35c580253ae44da4bbe6f"><td class="memTemplItemLeft" align="right" valign="top">_TpA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ace3b7f47a2c35c580253ae44da4bbe6f">dot</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _N &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ace3b7f47a2c35c580253ae44da4bbe6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the dot product of two vectors.  <a href="#ace3b7f47a2c35c580253ae44da4bbe6f">More...</a><br/></td></tr>
<tr class="separator:ace3b7f47a2c35c580253ae44da4bbe6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd8329802720665300d32daec48a502"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N&gt; </td></tr>
<tr class="memitem:afcd8329802720665300d32daec48a502"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#afcd8329802720665300d32daec48a502">cross</a> (const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;lhs, const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:afcd8329802720665300d32daec48a502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the cross product of two vectors.  <a href="#afcd8329802720665300d32daec48a502">More...</a><br/></td></tr>
<tr class="separator:afcd8329802720665300d32daec48a502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1470436ae35678ce84c7e934e5137c2b"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N, typename... _Vecs&gt; </td></tr>
<tr class="memitem:a1470436ae35678ce84c7e934e5137c2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a1470436ae35678ce84c7e934e5137c2b">cross</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; vec, _Vecs...args)</td></tr>
<tr class="memdesc:a1470436ae35678ce84c7e934e5137c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds cross product of <img class="formulaInl" alt="$n$" src="form_3.png"/> vectors.  <a href="#a1470436ae35678ce84c7e934e5137c2b">More...</a><br/></td></tr>
<tr class="separator:a1470436ae35678ce84c7e934e5137c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28c05c8976b72cb0beabb94e8a7a003"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N&gt; </td></tr>
<tr class="memitem:aa28c05c8976b72cb0beabb94e8a7a003"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#aa28c05c8976b72cb0beabb94e8a7a003">length</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; vec)</td></tr>
<tr class="memdesc:aa28c05c8976b72cb0beabb94e8a7a003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the length of given vector.  <a href="#aa28c05c8976b72cb0beabb94e8a7a003">More...</a><br/></td></tr>
<tr class="separator:aa28c05c8976b72cb0beabb94e8a7a003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79dc2977b5d010dda98e4e15e515eee"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N&gt; </td></tr>
<tr class="memitem:ab79dc2977b5d010dda98e4e15e515eee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#ab79dc2977b5d010dda98e4e15e515eee">normalize</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; vec)</td></tr>
<tr class="memdesc:ab79dc2977b5d010dda98e4e15e515eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normalized vector.  <a href="#ab79dc2977b5d010dda98e4e15e515eee">More...</a><br/></td></tr>
<tr class="separator:ab79dc2977b5d010dda98e4e15e515eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42604c7b610c64c880d429a911e9f59a"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N&gt; </td></tr>
<tr class="memitem:a42604c7b610c64c880d429a911e9f59a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a42604c7b610c64c880d429a911e9f59a">SphericalCoordinates</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; vec)</td></tr>
<tr class="memdesc:a42604c7b610c64c880d429a911e9f59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts vector into spherical coordinates.  <a href="#a42604c7b610c64c880d429a911e9f59a">More...</a><br/></td></tr>
<tr class="separator:a42604c7b610c64c880d429a911e9f59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ced6d3b0b4ba125bd6e01a400a0fb0"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , std::size_t _N&gt; </td></tr>
<tr class="memitem:a88ced6d3b0b4ba125bd6e01a400a0fb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classestl_1_1vector_1_1Vector.html#a88ced6d3b0b4ba125bd6e01a400a0fb0">CartesianCoordinates</a> (<a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; vec)</td></tr>
<tr class="memdesc:a88ced6d3b0b4ba125bd6e01a400a0fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts vector into cartesian coordinates.  <a href="#a88ced6d3b0b4ba125bd6e01a400a0fb0">More...</a><br/></td></tr>
<tr class="separator:a88ced6d3b0b4ba125bd6e01a400a0fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt;<br/>
class estl::vector::Vector&lt; _Tp, _N, _Al &gt;</h3>

<p><code>estl::matrix</code> is a container that encapsulates fixed size mathmatical vectors.</p>
<p>This container is an aggregate type with the same sematics as a struct holding a C-stype array <code>T[N]</code> as its only non-static data member. Elements of this container can be referenced witha single index.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Type of element. Required to be a complete type. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the container. </td></tr>
    <tr><td class="paramname">_Al</td><td>Allocator type, Not necessary in most situations. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0512c84eb9da2ef96933c52e53f83b0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::<a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This allocates the memory required for the desired vector. </p>

</div>
</div>
<a class="anchor" id="ac7bd7e927c5bff1c8ddb4fdfc245e24e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::<a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates the memory required for the vector and fills every element with the supplied value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcc123e158aedc61ea2be0110a379bda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::<a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates the memory required for the vector, and copies the elements fo the initializer list to the elements of the vector.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>Thows out of range if initializer_list is greater than the size of the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>initializer_list of elements to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0c2b54163113acb7a0e6f1a83eba65f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;class _InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::<a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates the memory required for the vector, and copies the contents of the memory between <code>first</code> and <code>last</code> to the elements of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_InputIt</td><td>Type of iterator of source data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First location in memory of source data. </td></tr>
    <tr><td class="paramname">last</td><td>Last location in memory of source data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae44885ca899838a4fe81a24e0127e9d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::<a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a>&lt; _Tp, _N, _Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates the memory required for the vector, and copies the elements of <code>vec</code> to the elements of the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1fa9b4cf1bb1c4df2cb2ee058a16896"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::size_t _Nc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::<a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a>&lt; _Tp, _Nc &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates the memory required for the vector, and copies the maximum number of elements from <code>vec</code> to the elements of the vector. If <code>vec</code> is smaller then the vector, then all the elements from <code>vec</code> are copied, then the remaining values are filled with <code>val</code>. If <code>vec</code> is larger then the vector, then only the first <code>_N</code> values from <code>vec</code> are copied into the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Nc</td><td>Number of elements in copy vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> to copy. </td></tr>
    <tr><td class="paramname">val</td><td>Value to pad remaining elements with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a118fec838f2ae13ea08e07eb6adeb5e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::~<a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocates the memory for the vector. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2e2d618ae707d488b451489937bd5282"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a975aa911d330359b5d7e0d2e99fbee11">reference</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the element at specified location <code>i</code>, with bounds checking. If <code>i</code> is not withing the range of the container, an exception of type <code>std::out_of_range</code> is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If <code>i</code> is outside of the range of the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Position of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a class="anchor" id="a228a5d1a6a4eab6fa95aa17efd66025f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ac1c0a66ac351178d43d81e05062a56c7">const_reference</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the element at specified location <code>i</code>, with bounds checking. If <code>i</code> is not withing the range of the container, an exception of type <code>std::out_of_range</code> is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If <code>i</code> is outside of the range of the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Position of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a class="anchor" id="a214d4c14b9e22e8b5769a261e1051ea7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a975aa911d330359b5d7e0d2e99fbee11">reference</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the element at specified location <code>i</code>. No bounds checking is preformed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Position of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b0f94919877665b7e85c580c98926f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ac1c0a66ac351178d43d81e05062a56c7">const_reference</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the element at specified location <code>i</code>. No bounds checking is preformed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Position of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a class="anchor" id="acb050b92bf0b3bd933739bf0c43c59ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a975aa911d330359b5d7e0d2e99fbee11">reference</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the first element in the container. Calling <code>front</code> on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="af9bb0d2b7b352aef31fbcf3e3273a837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ac1c0a66ac351178d43d81e05062a56c7">const_reference</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::font </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the first element in the container. Calling <code>front</code> on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="af4aab6274fb1748ab1029d8511b6a244"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a975aa911d330359b5d7e0d2e99fbee11">reference</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns reference to the last element in the container. Calling <code>back</code> on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="a3de38f429792b4a2ad24e528b6625c1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ac1c0a66ac351178d43d81e05062a56c7">const_reference</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns reference to the last element in the container. Calling <code>back</code> on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="aca694ce7312008b4a3f55ac93a8bc5f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a4ce99e05dd558f5840bb88e3509edca2">pointer</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns pointer to the underlying array serving as element storage. The pointer is such that range <code>[<a class="el" href="classestl_1_1vector_1_1Vector.html#aca694ce7312008b4a3f55ac93a8bc5f9" title="Direct access to the underlying array. ">data()</a>; <a class="el" href="classestl_1_1vector_1_1Vector.html#aca694ce7312008b4a3f55ac93a8bc5f9" title="Direct access to the underlying array. ">data()</a> + <a class="el" href="classestl_1_1vector_1_1Vector.html#a165c86c512ca83b36300fdf496bdf58a" title="Returns the number of elements. ">size()</a>]</code> is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. For non-empty containers, the returned pointer compares equal to the address of the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a208c8417fb33e0d798ef8ac44b1961b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a246922d9af90c7711c8e9e9ca65b34b9">const_pointer</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns pointer to the underlying array serving as element storage. The pointer is such that range <code>[<a class="el" href="classestl_1_1vector_1_1Vector.html#aca694ce7312008b4a3f55ac93a8bc5f9" title="Direct access to the underlying array. ">data()</a>; <a class="el" href="classestl_1_1vector_1_1Vector.html#aca694ce7312008b4a3f55ac93a8bc5f9" title="Direct access to the underlying array. ">data()</a> + <a class="el" href="classestl_1_1vector_1_1Vector.html#a165c86c512ca83b36300fdf496bdf58a" title="Returns the number of elements. ">size()</a>]</code> is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. For non-empty containers, the returned pointer compares equal to the address of the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a299540243ac3cd73d7b9339f546acc52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1matrix_1_1Matrix.html">estl::matrix::Matrix</a>&lt;_Tp, _N, 1&gt; <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::as_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a matrix representation of the vector, with a single column, and <code>N</code> rows. This can be useful for multiplying the vector by a matrix.</p>
<dl class="section return"><dt>Returns</dt><dd><code>Matrix</code> of <code>N</code> rows and <code>1</code> column, containing a copy of the entries in the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a32a86eea020fc10d5c3b2df4474c34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;_Tp&gt; <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::as_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the element at specified location <code>i</code>, with bounds checking. If <code>i</code> is not withing the range of the container, an exception of type <code>std::out_of_range</code> is thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If <code>i</code> is outside of the range of the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Position of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c41d88664c7bd5255c15d6f133c2fd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a13a0f0535f0e0a11fe1943a44c9ff607">iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the first element of the container. If the container is empty, the returned iterator will be equal to <code><a class="el" href="classestl_1_1vector_1_1Vector.html#ab03b417b120b029df7e2736cfe61d1ec" title="Returns an iterator to the end. ">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c12da6245d1b475cce328f8c5bd72e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the first element of the container. If the container is empty, the returned iterator will be equal to <code><a class="el" href="classestl_1_1vector_1_1Vector.html#ab03b417b120b029df7e2736cfe61d1ec" title="Returns an iterator to the end. ">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e8596db46a42eb027956e2829110942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the first element of the container. If the container is empty, the returned iterator will be equal to <code><a class="el" href="classestl_1_1vector_1_1Vector.html#ab03b417b120b029df7e2736cfe61d1ec" title="Returns an iterator to the end. ">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="ab03b417b120b029df7e2736cfe61d1ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a13a0f0535f0e0a11fe1943a44c9ff607">iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the lement following the last element of the container. This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7566150895d27105c0bc6ea07f915e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the lement following the last element of the container. This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="ab59c05f627800e53b492257dc82856bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the lement following the last element of the container. This element acts as a placeholder; attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="af6257898f724d9e616185dcea9a0e5ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a12e2a22c217006092bd7449aee770728">reverse_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reverssed containter.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d6536f15f1948d1c6c2a60ad2ed1f09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reverssed containter.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a84ade181925e9488c82616252161e098"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reverse iterator to the first element of the reversed container. It corresponds to the last element of the non-reverssed containter.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a0eec92c7c08a90edd5a038f4fc01e0f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a12e2a22c217006092bd7449aee770728">reverse_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reverse iterator to the lement following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b51665b8c53c0c0a6a00d30ba488c7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reverse iterator to the lement following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a10764afb7d8bd6d6baebd1c18e6430"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reverse iterator to the lement following the last element of the reversed container. It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder attempting to access it results in undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

</div>
</div>
<a class="anchor" id="a028a8acfc4a9fab5410b2fda87cced67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a13a0f0535f0e0a11fe1943a44c9ff607">iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the element that is located at <code>[i]</code> in the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of specified element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the specified element. </dd></dl>

</div>
</div>
<a class="anchor" id="a38552d1615079dd68acf60d3c99620cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the element that is located at <code>[i]</code> in the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of specified element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the specified element. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c2aa14ed32faba6db68a82734bc65a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a813f3151350d6fe485639252b8c892b6">const_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::celement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the element that is located at <code>[i]</code> in the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of specified element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the specified element. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c3d7ee344a0fd59c63db0d88acbdb50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#a12e2a22c217006092bd7449aee770728">reverse_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::relement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returnsd a reverse iterator to the element that is located at <code>[i]</code> in the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index to specified element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the specified element. </dd></dl>

</div>
</div>
<a class="anchor" id="adb7831218648aa7e8690dbbee785710f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::relement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returnsd a reverse iterator to the element that is located at <code>[i]</code> in the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index to specified element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the specified element. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bfd8f6608304be435f821b66d58edc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html#aca27cb927d826239612f023d3b6652b6">const_reverse_iterator</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::crelement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returnsd a reverse iterator to the element that is located at <code>[i]</code> in the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index to specified element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the specified element. </dd></dl>

</div>
</div>
<a class="anchor" id="a306fe2dc7af1506e9f0e96af502c86ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the container has no element, i.e. whether <code><a class="el" href="classestl_1_1vector_1_1Vector.html#a0c41d88664c7bd5255c15d6f133c2fd5" title="Retuns an iterator to the beginning. ">begin()</a> == <a class="el" href="classestl_1_1vector_1_1Vector.html#ab03b417b120b029df7e2736cfe61d1ec" title="Returns an iterator to the end. ">end()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the container is empty, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a165c86c512ca83b36300fdf496bdf58a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the container, i.e. <code>std::distance(<a class="el" href="classestl_1_1vector_1_1Vector.html#a0c41d88664c7bd5255c15d6f133c2fd5" title="Retuns an iterator to the beginning. ">begin()</a>, <a class="el" href="classestl_1_1vector_1_1Vector.html#ab03b417b120b029df7e2736cfe61d1ec" title="Returns an iterator to the end. ">end()</a>)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d35025478be6d9256ae5534a69091ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classestl_1_1vector_1_1Vector.html#ae155658c9b8cef8e57ab11fbb9e9bcff">size_type</a> <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum number of elements the container is able to hold do to system or library implementation limitations, i.e. <code>std::distance(<a class="el" href="classestl_1_1vector_1_1Vector.html#a0c41d88664c7bd5255c15d6f133c2fd5" title="Retuns an iterator to the beginning. ">begin()</a>, <a class="el" href="classestl_1_1vector_1_1Vector.html#ab03b417b120b029df7e2736cfe61d1ec" title="Returns an iterator to the end. ">end()</a>)</code> for the largest container.</p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6155f45c87f00a051d100f7f7997b9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html#a60b44de2b4b580f6bccefa391398550b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assigns the given value to all elements in the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to assign to the elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08cf9d4e660804dfe413c72c670e6c52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html">Vector</a>&lt; _Tp, _N, _Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exchanges the contantes of the container with those of <code>other</code>. Does not cuse iterators and references to associate with the other container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Container to exchange the contents with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04854ace12edc8445401a22ad7393542"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">_Tp(*)(_Tp)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For every element in the container, executs <code>func</code> with that element as the argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function that takes one parameter of type <code>_Tp</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1409797c8babaabd8db57c241e9b6b45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt;_Tp, _N&gt;&amp; <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const _T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the compund addition operator for vector arithmetic.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_T</td><td>Type to add to the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Value to add to the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>reference</code> of <code>*this</code> after arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a71abe1d1aa0232466339366fba775ce6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt;_Tp, _N&gt;&amp; <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const _T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the compund subtraction operator for vector arithmetic.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_T</td><td>Type to subtract from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Value to subtract from the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>reference</code> of <code>*this</code> after arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4e7a9be81dd41a4b13ecf72f5c3e72d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt;_Tp, _N&gt;&amp; <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const _T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the compund multiplication operator for vector arithmetic.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_T</td><td>Type to multiply to the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Value to multiply to the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>reference</code> of <code>*this</code> after arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="aa76b3ef91b33255e20ff01b38e88fba5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp, std::size_t _N, typename _Al = std::allocator&lt;_Tp&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt;_Tp, _N&gt;&amp; <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N, _Al &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const _T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the compund division operator for vector arithmetic.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_T</td><td>Type to divide the vector by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Value to divide the vector by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>reference</code> of <code>*this</code> after arithmetic operation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="adbd7f77fc3864f178eda7547a74324e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints the vector to the supplied stream. In the format of <code>&lt;...&gt;</code>;</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the container. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>OUtput stream to print to. </td></tr>
    <tr><td class="paramname">vec</td><td><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> to print.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output stream containing representation of the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a596c0b3989b44a687c27261090da5083"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the contents of <code>lhs</code> and <code>rhs</code> are equal, that is, whether each elemnt in <code>lhs</code> comapres equal with the elemnnt in <code>rhs</code> at the same position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type fo the first container. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of the second container. </td></tr>
    <tr><td class="paramname">_NA</td><td>Number of elements in the first container. </td></tr>
    <tr><td class="paramname">_NB</td><td>Number of elements in the second container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First vector to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second vector to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents of the containers are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5bd6f83e9fbfdad73d4a72e64f008c69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the contents of <code>lhs</code> and <code>rhs</code> are equal, that is, whether each elemnt in <code>lhs</code> comapres equal with the elemnnt in <code>rhs</code> at the same position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type fo the first container. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of the second container. </td></tr>
    <tr><td class="paramname">_NA</td><td>Number of elements in the first container. </td></tr>
    <tr><td class="paramname">_NB</td><td>Number of elements in the second container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First vector to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second vector to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents of the containers are not equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a143d10e4d209f7bdea4f530a3f323b4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>COmpares the contents of <code>lhs</code> and <code>rhs</code> lexicographically. The comparison is preformed by a function equivalent to <code>std::lexicographical_compare</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type fo the first container. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of the second container. </td></tr>
    <tr><td class="paramname">_NA</td><td>Number of elements in the first container. </td></tr>
    <tr><td class="paramname">_NB</td><td>Number of elements in the second container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First vector to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second vector to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents of <code>lhs</code> are lexicographically <em>less</em> than the contents of <code>rhs</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af1fb165566554b31708e293da1789f63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>COmpares the contents of <code>lhs</code> and <code>rhs</code> lexicographically. The comparison is preformed by a function equivalent to <code>std::lexicographical_compare</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type fo the first container. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of the second container. </td></tr>
    <tr><td class="paramname">_NA</td><td>Number of elements in the first container. </td></tr>
    <tr><td class="paramname">_NB</td><td>Number of elements in the second container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First vector to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second vector to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents of <code>lhs</code> are lexicographically <em>greater</em> than the contents of <code>rhs</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1193ce73fde6fb772519c24c7a078e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>COmpares the contents of <code>lhs</code> and <code>rhs</code> lexicographically. The comparison is preformed by a function equivalent to <code>std::lexicographical_compare</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type fo the first container. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of the second container. </td></tr>
    <tr><td class="paramname">_NA</td><td>Number of elements in the first container. </td></tr>
    <tr><td class="paramname">_NB</td><td>Number of elements in the second container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First vector to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second vector to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents of <code>lhs</code> are lexicographically <em>less</em> than or <em>equal</em> the contents of <code>rhs</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac18c1015e0785a16fa36b0571c3e4b49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares the contents of <code>lhs</code> and <code>rhs</code> lexicographically. The comparison is preformed by a function equivalent to <code>std::lexicographical_compare</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type fo the first container. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of the second container. </td></tr>
    <tr><td class="paramname">_NA</td><td>Number of elements in the first container. </td></tr>
    <tr><td class="paramname">_NB</td><td>Number of elements in the second container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First vector to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second vector to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the contents of <code>lhs</code> are lexicographically <em>greater</em> than or <em>equal</em> the contents of <code>rhs</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a35ceed4e2a12e85dd0e7a18ef83c9fea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N, typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the binary operators for vector arithmetic. Adds the scalar to every element of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vector. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector. </td></tr>
    <tr><td class="paramname">_T</td><td>Value type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector after the arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9efb0a2bd282f363ce5d9bd1f2331d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the binary operators for vector arithmetic. Lexicographically adds every element of <code>lhs</code> with the elemnt from <code>rhs</code> with the same position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">_NA</td><td>Number of elements in <code>lhs</code>. </td></tr>
    <tr><td class="paramname">_NB</td><td>Number of elements in <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector after the arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c418f3ca56ea60ac64fd75a1db6795f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N, typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the binary operators for vector arithmetic. Subtracts the scalar from every element of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vector. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector. </td></tr>
    <tr><td class="paramname">_T</td><td>Value type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector after the arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a76eebb11f92d90ddaefec9e16cd40580"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the binary operators for vector arithmetic. Lexicographically subtracts every element of <code>lhs</code> with the elemnt from <code>rhs</code> with the same position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">_NA</td><td>Number of elements in <code>lhs</code>. </td></tr>
    <tr><td class="paramname">_NB</td><td>Number of elements in <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector after the arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a13be3c4c651a77fe9dcc279f0c258429"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N, typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the binary operators for vector arithmetic. Multiples the scalar with every element of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vector. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector. </td></tr>
    <tr><td class="paramname">_T</td><td>Value type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector after the arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="af8c530c47c3df0f96df358f08a8798dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N, typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const _T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the binary operators for vector arithmetic. Multiples the scalar with every element of the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vector. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector. </td></tr>
    <tr><td class="paramname">_T</td><td>Value type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector after the arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a86b5833b438c7541ba83094dd6a159ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the binary operators for vector arithmetic. Lexicographically multiplies every element of <code>lhs</code> with the elemnt from <code>rhs</code> with the same position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">_NA</td><td>Number of elements in <code>lhs</code>. </td></tr>
    <tr><td class="paramname">_NB</td><td>Number of elements in <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector after the arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4908dfcae8559694dbb147c318ad1d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N, std::size_t _Nr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _Nr &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1matrix_1_1Matrix.html">estl::matrix::Matrix</a>&lt; _Tp, _Nr, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies a matrix by a vector. The columns in the matrix must equal the elements in the vector, otherwise there will be compilation errors. The result is a vector with the number of elements of the rows in the matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of <code>lhs</code> </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector, and columns in the matrix. </td></tr>
    <tr><td class="paramname">_Nr</td><td>Number of rows in the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Matrix to multiply vector against. </td></tr>
    <tr><td class="paramname">rhs</td><td><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> to multiply against matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> resulting from the multiplication. </dd></dl>

</div>
</div>
<a class="anchor" id="a23de99b2d76cfdc7a9e3ed8445f264cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N, typename _T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the binary operators for vector arithmetic. Divides element of the vector by the scalar.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vector. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector. </td></tr>
    <tr><td class="paramname">_T</td><td>Value type of the scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector after the arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a69901c1b931f3e1286401886447f92e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _NA, std::size_t _NB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _NA &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _NB &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements the binary operators for matrix arithmetic. Lexicographically divides every element of <code>lhs</code> with the elemnt from <code>rhs</code> with the same position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">_NA</td><td>Number of elements in <code>lhs</code>. </td></tr>
    <tr><td class="paramname">_NB</td><td>Number of elements in <code>rhs</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector after the arithmetic operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e6ab68502bc9f0a775ebe511b23b480"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Tp sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determins the sum of the elments in the vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vector. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>_Tp</code> representing the sum of the elements. </dd></dl>

</div>
</div>
<a class="anchor" id="ace3b7f47a2c35c580253ae44da4bbe6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TpA , typename _TpB , std::size_t _N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_TpA dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpA, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _TpB, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the dot product which is the sum of the products of corresponding entries in the two vectors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">_TpB</td><td>Value type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in both vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="afcd8329802720665300d32daec48a502"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the vector that is orthoganal to the plane containing <code>lhs</code> and <code>rhs</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_TpA</td><td>Value type of the vectors. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in each vector (should be 3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> that is perpendicular to both <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1470436ae35678ce84c7e934e5137c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N, typename... _Vecs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Vecs...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determins the vector perpendicular to all provided vectors. One must provide <img class="formulaInl" alt="$n-1$" src="form_4.png"/> <img class="formulaInl" alt="$n$" src="form_3.png"/> dimensional vectors. Thus for <img class="formulaInl" alt="$7$" src="form_5.png"/> dimensional vectors one must provide <img class="formulaInl" alt="$6$" src="form_6.png"/> vectors.</p>
<dl class="section note"><dt>Note</dt><dd>This will only function properly if the provided vectors are linearly independent.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vectors. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in each vector. </td></tr>
    <tr><td class="paramname">_Vecs</td><td>Packed type of vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The first vector. </td></tr>
    <tr><td class="paramname">args</td><td>Packed set of the remaining vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> that is perpendicular to all the provided vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="aa28c05c8976b72cb0beabb94e8a7a003"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Tp length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determins the length of the provided vector. This is the same as <img class="formulaInl" alt="$\sqrt{\vec{a}\cdot\vec{a}}$" src="form_7.png"/>. ```cpp vec = sqrt(dot(vec, vec)); ```</p>
<dl class="section warning"><dt>Warning</dt><dd>This can only be as accurate as <code>_Tp</code>, because the length is found in terms of <code>_Tp</code>. THis means that the value only has the abbility to be represented by a <code>_Tp</code> value. This means that if <code>_Tp</code> is <code>int</code>, then the length will not be accurate, as it requires square root, instead use <code>_Tp</code> as a <code>double</code> or <code>float</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vector. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to find the length of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ab79dc2977b5d010dda98e4e15e515eee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the normalized version of the provided vector. That is the length of the normalized vector is equal to <code>1</code>. This is the same as ```cpp vec = vec / length(vec); ```</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vector. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> to find the normalized version of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normal vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a42604c7b610c64c880d429a911e9f59a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; SphericalCoordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the vector position into spherical coordinates, such that the first term is the length, and subsiquent terms are angles.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vector. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Spherical representation of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a88ced6d3b0b4ba125bd6e01a400a0fb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , std::size_t _N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt; CartesianCoordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classestl_1_1vector_1_1Vector.html">estl::vector::Vector</a>&lt; _Tp, _N &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the vector representation into cartesian coordinates, such that the terms are positions in the unit basis.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Tp</td><td>Value type of the vector. </td></tr>
    <tr><td class="paramname">_N</td><td>Number of elements in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td><a class="el" href="classestl_1_1vector_1_1Vector.html" title="A standard container representing a mathmatical vector. ">Vector</a> to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cartesian representation of the vector. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>estl/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
